@using Models.Metadata
@using Models.UseCases.DisplayOnly.UseCase2
@using System.Collections
@using Attribute_Reflection_UseCase2_UserInteraction.Templates
@using System.Reflection
@using Radzen

@inject DialogService DialogService

@if (Details != null)
{
	foreach (var item in Details.GetType().GetProperties())
	{
		if (!basicTypes.Contains(item.PropertyType))
		{
			<div>@GetContainerTypeFragment(item)</div>
		}
		else
		{
			<div>@GetBasicTypeRenderFragment(item)</div>
		}
	}

	if (Details.GetType().GetCustomAttributes().Any(a => a.GetType() == typeof(EditableAttribute)))
	{
		<Radzen.Blazor.RadzenButton class=mt-3 Text=Save Click=this.SaveData></Radzen.Blazor.RadzenButton>
	}
}

@code {
	// An object mapping a property name to the complete path by which values can be bound to it, relative to the object
	// passed as parameter and stored in Details
	private Dictionary<string, List<string>> propertyBindingPathMap;

	private List<Type> basicTypes = new List<Type>()
	{
		typeof(bool),
		typeof(string),
		typeof(int),
		typeof(double)
	};

	[Parameter]
	public PersonalDetails? Details { get; set; }

	protected override void OnInitialized()
	{
		propertyBindingPathMap = new Dictionary<string, List<string>>();

		// The idea is to build a binding map consisting of a key (the property name) and the property to use for reading/writing.
		if (Details != null)
		{
			foreach (var item in Details.GetType().GetProperties())
			{
				if (!basicTypes.Contains(item.PropertyType) && !item.PropertyType.IsAssignableTo(typeof(IEnumerable)))
				{
					// Think about how to map complex type
				}
				else if (!basicTypes.Contains(item.PropertyType) && item.PropertyType.IsAssignableTo(typeof(IEnumerable)))
				{
					// Think about how to map collection
				}
				else
				{
					propertyBindingPathMap.Add(item.Name, new List<string>(){item.Name});
				}
			}
		}
	}

	private Dictionary<string, object> GetSimplePropertyTypeMap(Type type)
	{
		var map = new Dictionary<string, object>();

		var activated = Activator.CreateInstance(type);

		foreach (var item in type.GetProperties())
		{
			if (item.GetValue(activated) == null)
			{
				item.SetValue(activated, string.Empty);
			}

			map.Add(item.Name, item.GetValue(activated)!);
		}

		return map;
	}

	private RenderFragment GetContainerTypeFragment(PropertyInfo nonBasicTypeProperty)
	{
		if (nonBasicTypeProperty.PropertyType.IsAssignableTo(typeof(IEnumerable)))
		{
			return new RenderFragment(
	@<Radzen.Blazor.RadzenCard class=mt-3><div><CollectionView Data=@(nonBasicTypeProperty.GetValue(Details) as IEnumerable<object>)></CollectionView></div></Radzen.Blazor.RadzenCard>
	);
		}
		else
		{
			return new RenderFragment(
	@<Radzen.Blazor.RadzenCard class=mt-3>
		<div>
			<div class=row>
				@foreach (var item in nonBasicTypeProperty.PropertyType.GetProperties())
					{
						<div class="col-12 col-lg-6">@GetBasicTypeRenderFragment(item)</div>
					}
				</div>
			</div>
		</Radzen.Blazor.RadzenCard>
	);
		}
	}

	private RenderFragment GetBasicTypeRenderFragment(PropertyInfo propertyInfo)
	{
		// Think about how to use generated binding map to bind values in on changed methods.

		IEnumerable<string> propertyPathList = Enumerable.Empty<string>();

		if (this.propertyBindingPathMap.ContainsKey(propertyInfo.Name))
		{
			propertyPathList = propertyBindingPathMap[propertyInfo.Name];
		}

		if (propertyInfo.PropertyType == typeof(string))
		{
			return new RenderFragment(
	@<div>@propertyInfo.Name <Radzen.Blazor.RadzenTextBox class="mt-3" ValueChanged=@((val) => StringValueChanged(val, propertyPathList)) Placeholder=@propertyInfo.Name></Radzen.Blazor.RadzenTextBox></div>
	);
		}
		else if (propertyInfo.PropertyType == typeof(int))
		{
			return new RenderFragment(@<div class=col-6>@propertyInfo.Name <Radzen.Blazor.RadzenNumeric ValueChanged=@((val) => IntValueChanged(val, propertyPathList)) class=mt-3 TValue=int></Radzen.Blazor.RadzenNumeric></div>
	);
		}
		else
		{
			throw new ArgumentException(nameof(propertyInfo), "Non basic type detected");
		}
	}

	private async Task SaveData()
	{
		// View is borrowed for demonstration and confirmation that changes were made to object.
		await DialogService.OpenAsync("Successfully saved in database", ds =>
	@<div><PersonalDetailsComponent Details=Details></PersonalDetailsComponent></div>
	);
	}

	private void StringValueChanged(string newValue, IEnumerable<string> propertyPathList)
	{
		var property = this.GetPropertyReferenceRecursively(propertyPathList, this.Details!.GetType());

		property.SetValue(Details, newValue);
	}

	private void IntValueChanged(int newValue, IEnumerable<string> propertyPathList)
	{
		var property = this.GetPropertyReferenceRecursively(propertyPathList, this.Details!.GetType());

		property.SetValue(Details, newValue);
	}

	private PropertyInfo GetPropertyReferenceRecursively(IEnumerable<string> propertyPathList, Type currentBase)
	{
		// Make this work on deeper nested types too. Probably need to use activator create instance?
		if (!propertyPathList.Any())
		{
			throw new ArgumentException(nameof(propertyPathList), "PAth list must not be empty");
		}

		if (propertyPathList.Count() == 1)
		{
			return currentBase.GetProperties().Single(p => p.Name == propertyPathList.First());
		}

		currentBase = currentBase.GetProperties().Single(p => p.Name == propertyPathList.First()).GetType();
		return this.GetPropertyReferenceRecursively(propertyPathList.Skip(1), currentBase);
	}
}
