@using Attribute_Reflection_UseCase3_UserInteraction_Templates.Helpers
@using Attribute_Reflection_UseCase3_UserInteraction_Templates.Templates
@using Models
@using Models.Metadata
@using Models.UseCases.IncludingUserInteraction.UseCase3
@using System.Reflection
@using System.Collections

@if (ToolBox != null)
{
    foreach (var propertyInfo in ToolBox.GetType().GetProperties())
    {
        TemplateResult template = DecideTemplate(propertyInfo);
        var parameters = new Dictionary<string, object>()
        {
            {"Value", template.Value},
            {"Label", template.Label},
        };        
        
        <DynamicComponent Type=template.TemplateType Parameters="parameters"></DynamicComponent>
        <br />
    }
}

@code {
    [Parameter]
    public EditToolBox? ToolBox { get; set; }

    [Parameter]
    public PerformanceMonitor? PerformanceMonitor { get; set; }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            PerformanceMonitor!.Stop();
        }
    }

    private TemplateResult DecideTemplate(PropertyInfo info)
    {
        var asm = Assembly.GetExecutingAssembly();
        var templates = asm.GetTypes().Where(t => typeof(TemplateBase).IsAssignableFrom(t)).ToArray();
        var attributes = info.GetCustomAttributes().ToArray();

        if (info.PropertyType == typeof(int))
        {
            return GetIntegerTemplate(templates, attributes, info);
        }
        else if (info.PropertyType == typeof(Action))
        {
            return GetActionTemplate(templates, attributes, info);
        }
        else
        {
            return GetEnumerationTemplate(templates, attributes, info);
        }
    }

    private TemplateResult GetIntegerTemplate(IEnumerable<Type> templates, Attribute[] attributes, PropertyInfo info)
    {
        templates = templates.Where(t => t.GetCustomAttribute<ValueKindAttribute>()?.ValueKind == typeof(int)).ToArray();
        var template = ApplyFurtherTemplateConstraints(templates, attributes);

        var value = info.GetValue(ToolBox);

        return new TemplateResult(template, value!, info.Name);
    }

    private TemplateResult GetActionTemplate(IEnumerable<Type> templates, Attribute[] attributes, PropertyInfo info)
    {
        templates = templates.Where(t => t.GetCustomAttribute<ValueKindAttribute>()?.ValueKind == typeof(Action)).ToArray();
        var template = ApplyFurtherTemplateConstraints(templates, attributes);

        var value = info.GetValue(ToolBox);

        return new TemplateResult(template, value!, info.Name);

    }

    private TemplateResult GetEnumerationTemplate(IEnumerable<Type> templates, Attribute[] attributes, PropertyInfo info)
    {
        templates = templates.Where(t => t.GetCustomAttribute<ValueKindAttribute>()?.ValueKind == typeof(Enum)).ToArray();
        var template = ApplyFurtherTemplateConstraints(templates, attributes);

        var value = info.GetValue(ToolBox);

        return new TemplateResult(template, value!, info.Name);
    }

    private Type ApplyFurtherTemplateConstraints(IEnumerable<Type> templates, Attribute[] attributes)
    {
        bool isEditable = attributes.Any(a => a.GetType() == typeof(EditableAttribute));
        var stringLengthAttribute = attributes.FirstOrDefault(a => a.GetType() == typeof(StringLengthAttribute)) as StringLengthAttribute;

        if (isEditable)
        {
            templates = templates.Where(t => t.GetCustomAttributes().Any(a => a.GetType() == typeof(EditableAttribute))).ToArray();
        }

        if (stringLengthAttribute != null)
        {
            if (stringLengthAttribute.MaxLength > 49)
            {
                templates = templates.Where(t => t.GetCustomAttributes().Any(a => a.GetType() == typeof(MultilineAttribute))).ToArray();
            }
            else
            {
                templates = templates.Where(t => !t.GetCustomAttributes().Any(a => a.GetType() == typeof(MultilineAttribute))).ToArray();
            }
        }

        if (templates.Count() > 1)
        {
            throw new InvalidOperationException("Constraints not specific enough. Could not map to single template");
        }
        else if (!templates.Any())
        {
            throw new InvalidOperationException("No matching template found.");
        }

        return templates.First();
    }
}
